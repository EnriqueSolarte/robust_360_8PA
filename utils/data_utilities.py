from utils.geometry_utilities import isRotationMatrix
from config import Cfg
import os
from dataset_reader.MP3D_VO import MP3D_VO
from dataset_reader.TUM_VI import TUM_VI
import pandas as pd
import numpy as np
from utils.file_utilities import create_dir
from utils.file_utilities import create_file, write_file
import pandas as pd


def get_shape(array_map):
    """
     Useful function to get the shape of an image array regardless
     of its shape.
     :return (h, w)
    """
    if len(array_map.shape) > 2:
        h, w, c = array_map.shape
    else:
        h, w = array_map.shape
    return h, w


def get_dataset(cfg: Cfg):
    """
    Returns an object datatset
    """
    if cfg.params.dataset_name == "MP3D_VO":
        dataset_dir = cfg.DIR_MP3D_VO_DATASET
        scene = "{}/{}".format(cfg.params.scene, cfg.params.scene_version)
        cfg.dataset = MP3D_VO(dt_dir=dataset_dir, scene=scene)
        return cfg.dataset

    elif cfg.params.dataset_name == "TUM_VI":
        dataset_dir = cfg.DIR_TUM_VI_DATASET
        scene = "dataset-room{}_{}".format(cfg.params.scene, cfg.params.scene_version)
        cfg.dataset = TUM_VI(dt_dir=dataset_dir, scene=scene)
        return cfg.dataset


def get_data_dirname(cfg: Cfg):
    if cfg.params.dataset_name == "MP3D_VO":
        return os.path.join(
            cfg.DIR_ROOT,
            'data',
            cfg.params.dataset_name,
            cfg.params.scene,
            str(cfg.params.scene_version),
            cfg.tracked_or_sampled
        )
    else:
        return os.path.join(
            cfg.DIR_ROOT,
            'data',
            cfg.params.dataset_name,
            'dataset-room{}_{}'.format(cfg.params.scene, cfg.params.scene_version),
            cfg.tracked_or_sampled
        )


def save_bearings(*args, **kwargs):
    """
    Saves a set of bearings vectors into a file.txt to be used later, as backup, or simply for
    practical purposes. 
    A kwards dictionary is expected as input with the following keys:
    bearings_kf=bearings_kf,\n
    bearings_frm=bearings_frm,\n
    relative_pose=cam_a2b,\n
    idx_kf=idx_curr,\n
    idx_frm=idx_curr+1,\n
    cfg=self.cfg\n
    save_config=True\n
    save_camera_as="cam_gt.txt"\n
    """
    # > In case that the bearing vector were not calculated the whole
    # > fucntion is skiped
    if kwargs["bearings_kf"] is not None:
        # ! dataFrame generated by matches bearing vectors
        # [kfx, kfy, kfz, frmx, frmy, frmz] --> (n, 6)
        dt = pd.DataFrame(np.vstack((kwargs["bearings_kf"], kwargs["bearings_frm"])).T)

        dirname = get_data_dirname(kwargs["cfg"])

        # * DELETE PREVIOUS DATA INFO ONLY ONCE
        if kwargs.get("delete_previous", True):
            try:
                if kwargs["cfg"].newDataFlag:
                    create_dir(dirname, delete_previous=False)
            except:
                kwargs["cfg"].newDataFlag = True
                create_dir(dirname, delete_previous=True)

        file_bearings = "bearings_" + str(kwargs["idx_kf"]) + "_" + str(kwargs["idx_frm"]) + "_.txt"
        file_bearings = os.path.join(dirname, file_bearings)
        print("-")
        print("Saved filename:{}".format(file_bearings))
        print("Frames ref: Kf:{}   -   frm:{}".format(kwargs["idx_kf"], kwargs["idx_kf"]))
        print("Number of {}: {}".format(kwargs['cfg'].tracked_or_sampled, dt.shape[0]))
        dt.to_csv(file_bearings, header=None, index=None)

        if kwargs['save_config']:
            kwargs['cfg'].save_config(dirname=dirname)

        camera_pose_filename = kwargs.get("save_camera_as", "cam_pose.txt")
        pose_file = os.path.join(dirname, camera_pose_filename)
        flatten_pose = kwargs["relative_pose"].flatten()
        write_file(pose_file, tuple(flatten_pose))


def save_results(*args, **kwargs):
    dirname = get_data_dirname(kwargs["cfg"])
    np.save(os.path.join(dirname, "error.results"), kwargs["errors"])


def sampling_idxs(length, max_size):
    """
    Returns a set of suffled idxs
    """
    samples = np.linspace(0, length - 1, length).astype(np.int)
    if length > max_size:
        np.random.shuffle(samples)
        return samples[:max_size]
    else:
        return samples


def add_error_eval(error_eval, method_name, hist_errors):

    key_name = str.split(method_name, sep="by_")[1]
    if key_name in hist_errors.keys():
        hist_errors[key_name][0].append(error_eval[0])
        hist_errors[key_name][1].append(error_eval[1])

        hist_errors[key_name+"_rot_e"].append(np.median(hist_errors[key_name][0]))
        hist_errors[key_name+"_tra_e"].append(np.median(hist_errors[key_name][1]))
    else:
        hist_errors[key_name] = ([error_eval[0]], [error_eval[1]])
        hist_errors[key_name+"_rot_e"] = [error_eval[0]]
        hist_errors[key_name+"_tra_e"] = [error_eval[1]]

    print("Rot-e:{0:2e}\tTran-e:{1:2e}\t{2:}".format(
        np.median(hist_errors[key_name][0]),
        np.median(hist_errors[key_name][1]),
        key_name,
    ))

    return hist_errors


class SavedData:

    def __init__(self, cfg, tracked_or_sampled):
        self.cfg = cfg
        if tracked_or_sampled not in (cfg.FROM_TRACKED_BEARINGS, cfg.FROM_SAMPLED_BEARINGS):
            print("ERROR: tracked_or_sampled can be either \"cfg.FROM_TRACKED_BEARINGS\" or \"cfg.FROM_TRACKED_BEARINGS\". we got {}.".format(tracked_or_sampled))
            exit()
        if tracked_or_sampled == cfg.FROM_TRACKED_BEARINGS:
            cfg.tracked_or_sampled = cfg.FROM_TRACKED_BEARINGS
        else:
            cfg.tracked_or_sampled = cfg.FROM_SAMPLED_BEARINGS

        self.dirname = get_data_dirname(cfg)

        list_all_files = os.listdir(self.dirname)
        self.list_bearings_files = [f for f in list_all_files if "bearings" in f]
        self.list_cam_pose_files = [f for f in list_all_files if "cam_pose" in f]
        self.all_cam_poses = None
        self.idx = 0

    def get_bearings(self, idx=None, cam_pose=Cfg.CAM_POSES_GT, return_dict=False):

        if idx is None:
            idx = self.idx

        if idx < self.list_bearings_files.__len__():
            ret = True
            # ! Reading saved bearings vector
            bearings_file = os.path.join(self.dirname, self.list_bearings_files[idx])
            all_bearings = pd.read_csv(bearings_file, header=None).values
            aux_name = str.split(self.list_bearings_files[idx], sep=("_"))

            # ! Reading saved camera pose
            cam_pose_file = os.path.join(self.dirname, cam_pose)
            if self.all_cam_poses is None:
                self.all_cam_poses = pd.read_csv(cam_pose_file, header=None).values
            cam_pose = self.all_cam_poses[idx, :].reshape(4, 4)
            assert isRotationMatrix(cam_pose[0:3, 0:3])

            self.idx += 1
        else:
            ret = False

        if return_dict:
            if not ret:
                return None, ret
            return dict(
                bearings_kf=all_bearings[:, 0:3].T,
                bearings_frm=all_bearings[:, 3:].T,
                relative_pose=cam_pose,
                idx_kf=aux_name[1],
                idx_frm=aux_name[2],
                cfg=self.cfg
            ), True
        else:
            if not ret:
                return None, None, None, ret
            return all_bearings[:, 0:3].T, all_bearings[:, 3:].T, cam_pose, True
